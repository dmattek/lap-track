# Loads CP output (1-line header) and the output of MATLAB's LAP tracking implementation
# The matlab output from xxx_conn.csv is the output of tracksFinal(1:end).tracksFeatIndxCG
# that contains indices of objects from every frame that form a tracks

require(data.table)
require(tca)

DEB = 1

## Parse command-line params
args <- commandArgs(TRUE)

# List for storing params and defs
params = list()

# Path to config csv file
params$s.f.cfg = args[1]

# Path to CP output
# This directory is the root for all following directories
# E.g. myexp1/cp.out1/output/out_0001
params$s.dir.data = args[2]

if(sum(is.na(args[1:2])) > 0) {
  stop('Wrong number of parameters! Call: Rscript cleanCPoutCFG.R path_to_config_file path_to_cp_out')
}


## Parse config file
# Name of the parameter in config file that prescribes minimum track length
params$cfg.cpout1line = 'file_cpout_1line'
params$cfg.dirtracks = 'dir_lapout'

params$cfg.tracklen = 'min_track_length'
params$tracklen.default = 10

params$cfg.well = 'column_well'
params$s.well.default = "Metadata_Well"

params$cfg.fov = 'column_fov'
params$s.fov.default = "Metadata_Site"

params$cfg.frame = 'column_frame'
params$s.frame.default = "Metadata_T"

params$cfg.objnum.cp = 'column_objnum_cp'
params$s.objnum.cp.default = "objNuclei_ObjectNumber"

params$cfg.objnum.conn = 'column_objnum_conn'
params$s.objnum.conn.default = "ObjectNumber"

params$cfg.track = 'column_trackid'
params$s.track.default = "track_id"

# suffix to add to Well column to create a numeric Well column (used in Matlab output)
params$s.wellnum.suff = '_num'

# suffix to add to TrackID column to create a data-wide unique track ID
params$s.trackuni.suff = '_uni'

# suffix for the output file with clean tracks
params$s.f.track.suff = '_clean_tracks.csv'

# Filename suffixes in files generated by LAP that contain connectivity and sequence of tracks
params$s.lap.conn = 'conn'
params$s.lap.seq = 'seq'

# switch variable for data output
# set FALSE if you don't want processed data to be written to files
params$b.data.out = TRUE



## Read config file
# read the csv file; 2 columns only
dt.cfg = fread(params$s.f.cfg, select = 1:2)

# convert to a list
l.cfg = split(dt.cfg[[2]], dt.cfg[[1]])

# convert strings to appropriate types
l.cfg = tca::convertStringList2Types(l.cfg)

# These parameters have to be provided in the config file; no defaults
# 1-line header CP out file, e.g. objNuclei_1line.csv
if(params$cfg.cpout1line %in% names(l.cfg)) {
  params$s.f.cpout = l.cfg[[params$cfg.cpout1line]]
} else {
  stop(sprintf('Config file does not contain %s parameter; please provide, no default!', params$cfg.cpout1line))
}
# file core name (must be a 1-line header file)
params$s.f.core = gsub('.csv', '', params$s.f.cpout)

# Directory with LAP output csv's
# e.g. trackXY_objNuclei_1line
if(params$cfg.dirtracks %in% names(l.cfg)) {
  params$s.dir.tracks = l.cfg[[params$cfg.dirtracks]]
} else {
  stop(sprintf('Config file does not contain %s parameter; please provide, no default!', params$cfg.cpout1line))
}

# These parameters can be omitted in the config file; default values defined
# Assign minimum track length from config file
if(params$cfg.tracklen %in% names(l.cfg)) {
  params$tracklen = l.cfg[[params$cfg.tracklen]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.tracklen, params$tracklen.default))
  params$tracklen = params$tracklen.default
}

# Assign Well column from config file
if(params$cfg.well %in% names(l.cfg)) {
  params$s.well = l.cfg[[params$cfg.well]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.well, params$s.well.default))
  params$s.well = params$s.well.default
}

# Assign FOV column from config file
if(params$cfg.fov %in% names(l.cfg)) {
  params$s.fov = l.cfg[[params$cfg.fov]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.fov, params$s.fov.default))
  params$s.fov = params$s.fov.default
}

# Assign frame number column from config file
if(params$cfg.frame %in% names(l.cfg)) {
  params$s.frame = l.cfg[[params$cfg.frame]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.frame, params$s.frame.default))
  params$s.frame = params$s.frame.default
}

# Assign object number column from config file
if(params$cfg.objnum.cp %in% names(l.cfg)) {
  params$s.objnum.cp = l.cfg[[params$cfg.objnum.cp]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.objnum.cp, params$s.objnum.cp.default))
  params$s.objnum.cp = params$s.objnum.cp.default
}

# Assign object number column from config file
if(params$cfg.objnum.conn %in% names(l.cfg)) {
  params$s.objnum.conn = l.cfg[[params$cfg.objnum.conn]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.objnum.conn, params$s.objnum.conn.default))
  params$s.objnum.conn = params$s.objnum.conn.default
}

# Assign track ID column from config file
if(params$cfg.track %in% names(l.cfg)) {
  params$s.track = l.cfg[[params$cfg.track]]
} else {
  print(sprintf('Config file does not contain %s parameter; using default %d.', params$cfg.track, params$s.track.default))
  params$s.track = params$s.track.default
}

# column name with unique track ID (created in this script)
params$s.trackuni = paste0(params$s.track, params$s.trackuni.suff)

cat("Working directory: ", params$s.dir.data, "\n")
cat("CP out file core : ", params$s.f.core, "\n")
cat("LAP output dir   : ", params$s.dir.tracks, "\n")
cat("Minimum track len: ", params$tracklen, "\n")

#cat('Setting current directory to:\n')
#cat(params$s.dir.data, '\n\n')
#setwd(params$s.dir.data)

# files with track connectivities and sequence
params$s.f.data.con = list.files(file.path(params$s.dir.data, params$s.dir.tracks), paste0(params$s.lap.conn, ".csv"))
params$s.f.data.seq = list.files(file.path(params$s.dir.data, params$s.dir.tracks), paste0(params$s.lap.seq, ".csv"))

# load data
if(DEB) {
	cat(sprintf('Reading CP output from: %s\n', file.path(params$s.dir.data, params$s.f.cpout)))
	cat(sprintf('Reading LAP out - conn: %s\n', file.path(params$s.dir.data, params$s.dir.tracks, params$s.f.data.con)))
	cat(sprintf('Reading LAP out - seq : %s\n', file.path(params$s.dir.data, params$s.dir.tracks, params$s.f.data.seq)))
}

dt.cp  = fread(file.path(params$s.dir.data, params$s.f.cpout))
dt.con = fread(file.path(params$s.dir.data, params$s.dir.tracks, params$s.f.data.con))
dt.seq = fread(file.path(params$s.dir.data, params$s.dir.tracks, params$s.f.data.seq))

# Matlab output is entirely numeric
# Metadata_Well column contains numbers that enumnerate consecutive wells from the original table
# check whether CP output contains Well column defined by params$s.well


if (params$s.well == 'none') {
  # No Well column in data
  b.well = 0
} else {
  # data contains Well column
  b.well = 1
  
  # all unique well names (alphanumeric)
  v.wells = unique(dt.cp[[params$s.well]])
  
  # dt with alphanumeric well names and corresponding successive numbers
  dt.wells = data.table(tmp1 = v.wells, 
                        tmp2 = 1:length(v.wells))
  setnames(dt.wells, c(params$s.well, paste0(params$s.well, params$s.wellnum.suff)))

  # add a column with well names and their correspodning numbers
  dt.con = merge(dt.con, dt.wells)
  
}

# merge connectivities with data
# dt.con holds the output from MATLAB with object numbers that belong to individual tracks
# Each of these object numbers is merged with data from CP output
if (b.well) {
  dt.concp = merge(dt.con, dt.cp, 
                   by.x = c(params$s.well, params$s.fov, params$s.frame, params$s.objnum.conn), 
                   by.y = c(params$s.well, params$s.fov, params$s.frame, params$s.objnum.cp), 
                   all.x = T)  
  setkeyv(dt.concp, c(params$s.well, params$s.fov, params$s.track))

  # add unique track id
  dt.concp[, (params$s.trackuni) := paste0(get(params$s.well), '_', get(params$s.fov), '_', get(params$s.track))]

} else {
  dt.concp = merge(dt.con, dt.cp,
                   by.x = c(params$s.fov, params$s.frame, params$s.objnum.conn),
                   by.y = c(params$s.fov, params$s.frame, params$s.objnum.cp),
                   all.x = T)
  setkeyv(dt.concp, c(params$s.fov, params$s.track))
  
  # add unique track id
  dt.concp[, (params$s.trackuni) := paste0(get(params$s.fov), '_', get(params$s.track))]
  
}

# calculate length of tracks (end - start); might include breaks
dt.tracklen = dt.concp[, .N, by = c(params$s.trackuni)]

# list of track ids that are longer than the threshold params$tracklen
v.longtrackid = dt.tracklen[N > params$tracklen, get(params$s.trackuni)]

# get only tracks longer than the threshold params$tracklen
dt.concp.sub = dt.concp[get(params$s.trackuni) %in% v.longtrackid]

if (b.well)
  setkeyv(dt.concp.sub, c(params$s.well, params$s.fov, params$s.track)) else
setkeyv(dt.concp.sub, c(params$s.fov, params$s.track))



# save a reduced dataset with:
# Image_Metadata_Well Image_Metadata_Site Image_Metadata_T
# track_id - track ID from u-track (it's unique per analysis; if analysis with u-track was performed on the entire dataset, track_id is unique)
# all measurements as in the full data set
# ONLY CELLS with tracks longer than the threshold params$tracklen


if (b.well)
{
  v.metacols = c(params$s.well, params$s.fov, params$s.frame, params$s.track, params$s.trackuni)
  v.allcols  = union(names(dt.concp.sub), v.metacols) 
  fwrite(x = dt.concp.sub[, (v.allcols), with = FALSE], 
            file = file.path(params$s.dir.data, paste0(params$s.f.core, params$s.f.track.suff)), 
            row.names = F, quote = F)  
} else {
  v.metacols = c(params$s.fov, params$s.frame, params$s.track, params$s.trackuni)
  v.allcols  = union(names(dt.concp.sub), v.metacols) 
  fwrite(x = dt.concp.sub[, (v.allcols), with = FALSE],
             file = file.path(params$s.dir.data, paste0(params$s.f.core, params$s.f.track.suff)),
             row.names = F, quote = F)
}
